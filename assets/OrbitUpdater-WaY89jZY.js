import{V as g}from"./ValueWithRandom-C8gtC9b7.js";import{A as y}from"./AnimationOptions-CqnKjqNH.js";import{s as d,k as O,F as p,G as a,r as k}from"./index-CKF4anYh.js";import{O as P}from"./OptionsColor-Cd26pwu5.js";class A extends g{constructor(){super(),this.value=45}load(i){i!==void 0&&super.load(i)}}class W{constructor(){this.animation=new y,this.enable=!1,this.opacity=1,this.rotation=new A,this.width=1}load(i){i&&(this.animation.load(i.animation),this.rotation.load(i.rotation),i.enable!==void 0&&(this.enable=i.enable),i.opacity!==void 0&&(this.opacity=d(i.opacity)),i.width!==void 0&&(this.width=d(i.width)),i.radius!==void 0&&(this.radius=d(i.radius)),i.color!==void 0&&(this.color=P.create(this.color,i.color)))}}const I=0,S=.5,C=2;function v(e,i,t,n,o,r,s,R,m){if(r<=I)return;const f=i.getPosition();t&&(e.strokeStyle=O(t,o)),e.lineWidth=r;const w=p(s);e.beginPath(),e.ellipse(f.x,f.y,n*S,n*C,w,R,m),e.stroke()}const E=2,F=.5,u=Math.PI*E,l=0,b=Math.PI*F,h=Math.PI+b,H=0,M=1,V=1,c=0;class G{constructor(i){this.container=i}afterDraw(i){const t=i.options.orbit;t!=null&&t.enable&&this.drawOrbit(i,"front")}beforeDraw(i){const t=i.options.orbit;t!=null&&t.enable&&this.drawOrbit(i,"back")}drawOrbit(i,t){const n=this.container;let o,r;switch(t){case"back":o=b,r=h;break;case"front":o=h,r=b;break;default:o=H,r=u}n.canvas.draw(s=>{v(s,i,i.orbitColor??i.getFillColor(),i.retina.orbitRadius??n.retina.orbitRadius??i.getRadius(),i.orbitOpacity??M,i.orbitWidth??V,(i.orbitRotation??c)*n.retina.pixelRatio,o,r)})}init(i){const t=this.container,n=i.options,o=n.orbit;o!=null&&o.enable&&(i.orbitRotation=a(o.rotation.value),i.orbitColor=k(o.color),i.retina.orbitRadius=o.radius!==void 0?a(o.radius)*t.retina.pixelRatio:void 0,t.retina.orbitRadius=i.retina.orbitRadius,i.orbitAnimationSpeed=o.animation.enable?a(o.animation.speed):l,i.orbitWidth=a(o.width),i.orbitOpacity=a(o.opacity))}isEnabled(i){var n;const t=(n=i.options.orbit)==null?void 0:n.animation;return!i.destroyed&&!i.spawning&&!!(t!=null&&t.enable)}loadOptions(i,...t){i.orbit||(i.orbit=new W);for(const n of t)i.orbit.load(n==null?void 0:n.orbit)}update(i,t){this.isEnabled(i)&&(i.orbitRotation===void 0&&(i.orbitRotation=c),i.orbitRotation+=(i.orbitAnimationSpeed??l/u)*t.factor)}}export{G as OrbitUpdater};
