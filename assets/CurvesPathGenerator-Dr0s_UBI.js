import{I as d,O as y,a0 as F,i as H}from"./index-B5p0OL-A.js";function w(u,e,t,o,f=0,v=1){const h=[],a=[],r=[],V=[],l=[],s=u??d;let g=0;t<1&&(t=1);for(let n=1;n<=t;++n)h[n]=s(),a[n]=s(),r[n]=n===1?1:r[n-1]*o,g+=r[n],V[n]=n/e,l[n]=s();return r.forEach((n,c)=>r[c]=n/g*(v-f)),()=>{let n,c,m=0;for(let i=t;i>=1;--i)n=l[i]+=V[i],l[i]>=1&&(n=l[i]-=1,h[i]=a[i],a[i]=s()),c=n**2*(3-2*n),m+=(h[i]*(1-c)+a[i]*c)*r[i];return m+f}}const G=2,p=Math.PI*G;function P(){return d()*.6+.8}class I{constructor(){this.options={rndFunc:null,period:100,nbHarmonics:2,attenHarmonics:.8,lowValue:-.03,highValue:.03}}generate(e){if(!e.pathGen){const t=this.options;e.pathGen=w(t.rndFunc,t.period,t.nbHarmonics,t.attenHarmonics,t.lowValue,t.highValue)}return e.curveVelocity?(e.curveVelocity.length+=.01,e.curveVelocity.angle=(e.curveVelocity.angle+e.pathGen())%p):(e.curveVelocity=y.origin,e.curveVelocity.length=P(),e.curveVelocity.angle=d()*p),e.velocity.x=0,e.velocity.y=0,e.curveVelocity}init(e){const t=e.actualOptions.particles.move.path.options,{options:o}=this;F(t.rndFunc)?o.rndFunc=t.rndFunc:H(t.rndFunc)&&(o.rndFunc=window[t.rndFunc]??this.options.rndFunc),o.period=t.period??o.period,o.nbHarmonics=t.nbHarmonics??o.nbHarmonics,o.attenHarmonics=t.attenHarmonics??o.attenHarmonics,o.lowValue=t.lowValue??o.lowValue,o.highValue=t.highValue??o.highValue}reset(e){delete e.pathGen,delete e.curveVelocity}update(){}}export{I as CurvesPathGenerator};
